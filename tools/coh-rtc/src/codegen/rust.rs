// Author: Lukas Bower
// Purpose: Emit deterministic Rust bootstrap tables for the root task.

use crate::codegen::hash_bytes;
use crate::ir::{Manifest, Role};
use anyhow::{Context, Result};
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

pub fn emit_rust(manifest: &Manifest, manifest_hash: &str, out_dir: &Path) -> Result<()> {
    let mod_rs = out_dir.join("mod.rs");
    let bootstrap_rs = out_dir.join("bootstrap.rs");

    let mut mod_contents = String::new();
    writeln!(mod_contents, "// Author: Lukas Bower")?;
    writeln!(mod_contents, "// Purpose: Generated root-task manifest tables and helpers.")?;
    writeln!(mod_contents, "// @generated by coh-rtc; do not edit.")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#![allow(clippy::all)]")?;
    writeln!(mod_contents, "#![allow(dead_code)]")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "use cohesix_ticket::Role;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "mod bootstrap;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TicketSpec {{")?;
    writeln!(mod_contents, "    pub role: Role,")?;
    writeln!(mod_contents, "    pub secret: &'static str,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct NamespaceMount {{")?;
    writeln!(mod_contents, "    pub service: &'static str,")?;
    writeln!(mod_contents, "    pub target: &'static [&'static str],")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct CachePolicy {{")?;
    writeln!(mod_contents, "    pub kernel_ops: bool,")?;
    writeln!(mod_contents, "    pub dma_clean: bool,")?;
    writeln!(mod_contents, "    pub dma_invalidate: bool,")?;
    writeln!(mod_contents, "    pub unify_instructions: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub enum ShortWritePolicy {{")?;
    writeln!(mod_contents, "    Reject,")?;
    writeln!(mod_contents, "    Retry,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct Secure9pLimits {{")?;
    writeln!(mod_contents, "    pub msize: u32,")?;
    writeln!(mod_contents, "    pub walk_depth: u8,")?;
    writeln!(mod_contents, "    pub tags_per_session: u16,")?;
    writeln!(mod_contents, "    pub batch_frames: u16,")?;
    writeln!(mod_contents, "    pub short_write_policy: ShortWritePolicy,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const MANIFEST_SCHEMA: &str = \"{}\";", manifest.root_task.schema)?;
    writeln!(mod_contents, "pub const MANIFEST_SHA256: &str = \"{}\";", manifest_hash)?;
    writeln!(mod_contents, "pub const TICKET_TABLE_SHA256: &str = bootstrap::TICKET_TABLE_SHA256;")?;
    writeln!(mod_contents, "pub const NAMESPACE_TABLE_SHA256: &str = bootstrap::NAMESPACE_TABLE_SHA256;")?;
    writeln!(mod_contents, "pub const AUDIT_TABLE_SHA256: &str = bootstrap::AUDIT_TABLE_SHA256;")?;
    writeln!(mod_contents, "pub const CACHE_POLICY: CachePolicy = bootstrap::CACHE_POLICY;")?;
    writeln!(mod_contents, "pub const SECURE9P_LIMITS: Secure9pLimits = bootstrap::SECURE9P_LIMITS;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn ticket_inventory() -> &'static [TicketSpec] {{")?;
    writeln!(mod_contents, "    &bootstrap::TICKET_INVENTORY")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn namespace_mounts() -> &'static [NamespaceMount] {{")?;
    writeln!(mod_contents, "    &bootstrap::NAMESPACE_MOUNTS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn initial_audit_lines() -> &'static [&'static str] {{")?;
    writeln!(mod_contents, "    &bootstrap::INITIAL_AUDIT_LINES")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn cache_policy() -> CachePolicy {{")?;
    writeln!(mod_contents, "    bootstrap::CACHE_POLICY")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn secure9p_limits() -> Secure9pLimits {{")?;
    writeln!(mod_contents, "    bootstrap::SECURE9P_LIMITS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const TICKET_COUNT: usize = bootstrap::TICKET_INVENTORY.len();")?;

    let ticket_hash = hash_bytes(
        serde_json::to_vec(&manifest.tickets).context("serialize tickets")?.as_slice(),
    );
    let namespace_hash = hash_bytes(
        serde_json::to_vec(&manifest.namespaces.mounts)
            .context("serialize namespaces")?
            .as_slice(),
    );

    let audit_lines = build_audit_lines(manifest, manifest_hash);
    let audit_hash = hash_bytes(
        serde_json::to_vec(&audit_lines)
            .context("serialize audit lines")?
            .as_slice(),
    );

    let mut bootstrap_contents = String::new();
    writeln!(bootstrap_contents, "// Author: Lukas Bower")?;
    writeln!(bootstrap_contents, "// Purpose: Generated manifest tables for root-task bootstrap.")?;
    writeln!(bootstrap_contents, "// @generated by coh-rtc; do not edit.")?;
    writeln!(bootstrap_contents)?;
    writeln!(
        bootstrap_contents,
        "use super::{{CachePolicy, NamespaceMount, Secure9pLimits, ShortWritePolicy, TicketSpec}};"
    )?;
    writeln!(bootstrap_contents, "use cohesix_ticket::Role;")?;
    writeln!(bootstrap_contents)?;
    writeln!(bootstrap_contents, "pub const TICKET_TABLE_SHA256: &str = \"{}\";", ticket_hash)?;
    writeln!(bootstrap_contents, "pub const NAMESPACE_TABLE_SHA256: &str = \"{}\";", namespace_hash)?;
    writeln!(bootstrap_contents, "pub const AUDIT_TABLE_SHA256: &str = \"{}\";", audit_hash)?;
    writeln!(bootstrap_contents)?;

    writeln!(bootstrap_contents, "pub const TICKET_INVENTORY: [TicketSpec; {}] = [", manifest.tickets.len())?;
    for ticket in &manifest.tickets {
        writeln!(
            bootstrap_contents,
            "    TicketSpec {{ role: {}, secret: \"{}\" }},",
            role_to_rust(ticket.role),
            escape_literal(&ticket.secret)
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const NAMESPACE_MOUNTS: [NamespaceMount; {}] = [",
        manifest.namespaces.mounts.len()
    )?;
    for mount in &manifest.namespaces.mounts {
        let target = mount
            .target
            .iter()
            .map(|seg| format!("\"{}\"", escape_literal(seg)))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(
            bootstrap_contents,
            "    NamespaceMount {{ service: \"{}\", target: &[{}] }},",
            escape_literal(&mount.service),
            target
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const CACHE_POLICY: CachePolicy = CachePolicy {{ kernel_ops: {}, dma_clean: {}, dma_invalidate: {}, unify_instructions: {} }};\n",
        manifest.cache.kernel_ops,
        manifest.cache.dma_clean,
        manifest.cache.dma_invalidate,
        manifest.cache.unify_instructions
    )?;
    writeln!(
        bootstrap_contents,
        "pub const SECURE9P_LIMITS: Secure9pLimits = Secure9pLimits {{ msize: {}, walk_depth: {}, tags_per_session: {}, batch_frames: {}, short_write_policy: {} }};\n",
        manifest.secure9p.msize,
        manifest.secure9p.walk_depth,
        manifest.secure9p.tags_per_session,
        manifest.secure9p.batch_frames,
        short_write_policy_to_rust(&manifest.secure9p.short_write.policy)
    )?;

    writeln!(
        bootstrap_contents,
        "pub const INITIAL_AUDIT_LINES: [&str; {}] = [",
        audit_lines.len()
    )?;
    for line in &audit_lines {
        writeln!(bootstrap_contents, "    \"{}\",", escape_literal(line))?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    write_if_changed(&mod_rs, &mod_contents)?;
    write_if_changed(&bootstrap_rs, &bootstrap_contents)?;

    Ok(())
}

fn role_to_rust(role: Role) -> &'static str {
    match role {
        Role::Queen => "Role::Queen",
        Role::WorkerHeartbeat => "Role::WorkerHeartbeat",
        Role::WorkerGpu => "Role::WorkerGpu",
    }
}

fn short_write_policy_to_rust(policy: &crate::ir::ShortWritePolicy) -> &'static str {
    match policy {
        crate::ir::ShortWritePolicy::Reject => "ShortWritePolicy::Reject",
        crate::ir::ShortWritePolicy::Retry => "ShortWritePolicy::Retry",
    }
}

fn short_write_policy_label(policy: &crate::ir::ShortWritePolicy) -> &'static str {
    match policy {
        crate::ir::ShortWritePolicy::Reject => "reject",
        crate::ir::ShortWritePolicy::Retry => "retry",
    }
}

fn build_audit_lines(manifest: &Manifest, manifest_hash: &str) -> Vec<String> {
    vec![
        format!("manifest.schema={}", manifest.root_task.schema),
        format!("manifest.profile={}", manifest.profile.name),
        format!("manifest.sha256={}", manifest_hash),
        format!("manifest.tickets={}", manifest.tickets.len()),
        format!(
            "manifest.namespaces={} role_isolation={}",
            manifest.namespaces.mounts.len(),
            manifest.namespaces.role_isolation
        ),
        format!("manifest.secure9p.msize={}", manifest.secure9p.msize),
        format!(
            "manifest.secure9p.walk_depth={}",
            manifest.secure9p.walk_depth
        ),
        format!(
            "manifest.secure9p.tags_per_session={}",
            manifest.secure9p.tags_per_session
        ),
        format!(
            "manifest.secure9p.batch_frames={}",
            manifest.secure9p.batch_frames
        ),
        format!(
            "manifest.secure9p.short_write.policy={}",
            short_write_policy_label(&manifest.secure9p.short_write.policy)
        ),
        format!("manifest.cache.kernel_ops={}", manifest.cache.kernel_ops),
        format!("manifest.cache.dma_clean={}", manifest.cache.dma_clean),
        format!(
            "manifest.cache.dma_invalidate={}",
            manifest.cache.dma_invalidate
        ),
        format!(
            "manifest.cache.unify_instructions={}",
            manifest.cache.unify_instructions
        ),
        format!("manifest.features.net_console={}", manifest.features.net_console),
    ]
}

fn write_if_changed(path: &Path, contents: &str) -> Result<()> {
    // Always rewrite so mtimes advance when the manifest changes; build.rs enforces freshness by time.
    fs::write(path, contents).with_context(|| format!("failed to write {}", path.display()))?;
    Ok(())
}

fn escape_literal(value: &str) -> String {
    value.chars().flat_map(|c| c.escape_default()).collect()
}
