// Author: Lukas Bower
// Purpose: Emit deterministic Rust bootstrap tables for the root task.

use crate::codegen::hash_bytes;
use crate::ir::{Manifest, Role};
use anyhow::{Context, Result};
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

pub fn emit_rust(manifest: &Manifest, manifest_hash: &str, out_dir: &Path) -> Result<()> {
    let mod_rs = out_dir.join("mod.rs");
    let bootstrap_rs = out_dir.join("bootstrap.rs");

    let mut mod_contents = String::new();
    writeln!(mod_contents, "// Author: Lukas Bower")?;
    writeln!(mod_contents, "// Purpose: Generated root-task manifest tables and helpers.")?;
    writeln!(mod_contents, "// @generated by coh-rtc; do not edit.")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#![allow(clippy::all)]")?;
    writeln!(mod_contents, "#![allow(dead_code)]")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "use cohesix_ticket::Role;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "mod bootstrap;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TicketSpec {{")?;
    writeln!(mod_contents, "    pub role: Role,")?;
    writeln!(mod_contents, "    pub secret: &'static str,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct NamespaceMount {{")?;
    writeln!(mod_contents, "    pub service: &'static str,")?;
    writeln!(mod_contents, "    pub target: &'static [&'static str],")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const MANIFEST_SCHEMA: &str = \"{}\";", manifest.root_task.schema)?;
    writeln!(mod_contents, "pub const MANIFEST_SHA256: &str = \"{}\";", manifest_hash)?;
    writeln!(mod_contents, "pub const TICKET_TABLE_SHA256: &str = bootstrap::TICKET_TABLE_SHA256;")?;
    writeln!(mod_contents, "pub const NAMESPACE_TABLE_SHA256: &str = bootstrap::NAMESPACE_TABLE_SHA256;")?;
    writeln!(mod_contents, "pub const AUDIT_TABLE_SHA256: &str = bootstrap::AUDIT_TABLE_SHA256;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn ticket_inventory() -> &'static [TicketSpec] {{")?;
    writeln!(mod_contents, "    &bootstrap::TICKET_INVENTORY")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn namespace_mounts() -> &'static [NamespaceMount] {{")?;
    writeln!(mod_contents, "    &bootstrap::NAMESPACE_MOUNTS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn initial_audit_lines() -> &'static [&'static str] {{")?;
    writeln!(mod_contents, "    &bootstrap::INITIAL_AUDIT_LINES")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const TICKET_COUNT: usize = bootstrap::TICKET_INVENTORY.len();")?;

    let ticket_hash = hash_bytes(
        serde_json::to_vec(&manifest.tickets).context("serialize tickets")?.as_slice(),
    );
    let namespace_hash = hash_bytes(
        serde_json::to_vec(&manifest.namespaces.mounts)
            .context("serialize namespaces")?
            .as_slice(),
    );

    let audit_lines = build_audit_lines(manifest, manifest_hash);
    let audit_hash = hash_bytes(
        serde_json::to_vec(&audit_lines)
            .context("serialize audit lines")?
            .as_slice(),
    );

    let mut bootstrap_contents = String::new();
    writeln!(bootstrap_contents, "// Author: Lukas Bower")?;
    writeln!(bootstrap_contents, "// Purpose: Generated manifest tables for root-task bootstrap.")?;
    writeln!(bootstrap_contents, "// @generated by coh-rtc; do not edit.")?;
    writeln!(bootstrap_contents)?;
    writeln!(bootstrap_contents, "use super::{{NamespaceMount, TicketSpec}};")?;
    writeln!(bootstrap_contents, "use cohesix_ticket::Role;")?;
    writeln!(bootstrap_contents)?;
    writeln!(bootstrap_contents, "pub const TICKET_TABLE_SHA256: &str = \"{}\";", ticket_hash)?;
    writeln!(bootstrap_contents, "pub const NAMESPACE_TABLE_SHA256: &str = \"{}\";", namespace_hash)?;
    writeln!(bootstrap_contents, "pub const AUDIT_TABLE_SHA256: &str = \"{}\";", audit_hash)?;
    writeln!(bootstrap_contents)?;

    writeln!(bootstrap_contents, "pub const TICKET_INVENTORY: [TicketSpec; {}] = [", manifest.tickets.len())?;
    for ticket in &manifest.tickets {
        writeln!(
            bootstrap_contents,
            "    TicketSpec {{ role: {}, secret: \"{}\" }},",
            role_to_rust(ticket.role),
            escape_literal(&ticket.secret)
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const NAMESPACE_MOUNTS: [NamespaceMount; {}] = [",
        manifest.namespaces.mounts.len()
    )?;
    for mount in &manifest.namespaces.mounts {
        let target = mount
            .target
            .iter()
            .map(|seg| format!("\"{}\"", escape_literal(seg)))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(
            bootstrap_contents,
            "    NamespaceMount {{ service: \"{}\", target: &[{}] }},",
            escape_literal(&mount.service),
            target
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const INITIAL_AUDIT_LINES: [&str; {}] = [",
        audit_lines.len()
    )?;
    for line in &audit_lines {
        writeln!(bootstrap_contents, "    \"{}\",", escape_literal(line))?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    write_if_changed(&mod_rs, &mod_contents)?;
    write_if_changed(&bootstrap_rs, &bootstrap_contents)?;

    Ok(())
}

fn role_to_rust(role: Role) -> &'static str {
    match role {
        Role::Queen => "Role::Queen",
        Role::WorkerHeartbeat => "Role::WorkerHeartbeat",
        Role::WorkerGpu => "Role::WorkerGpu",
    }
}

fn build_audit_lines(manifest: &Manifest, manifest_hash: &str) -> Vec<String> {
    vec![
        format!("manifest.schema={}", manifest.root_task.schema),
        format!("manifest.profile={}", manifest.profile.name),
        format!("manifest.sha256={}", manifest_hash),
        format!("manifest.tickets={}", manifest.tickets.len()),
        format!(
            "manifest.namespaces={} role_isolation={}",
            manifest.namespaces.mounts.len(),
            manifest.namespaces.role_isolation
        ),
        format!("manifest.secure9p.msize={}", manifest.secure9p.msize),
        format!(
            "manifest.secure9p.walk_depth={}",
            manifest.secure9p.walk_depth
        ),
        format!("manifest.features.net_console={}", manifest.features.net_console),
    ]
}

fn write_if_changed(path: &Path, contents: &str) -> Result<()> {
    // Always rewrite so mtimes advance when the manifest changes; build.rs enforces freshness by time.
    fs::write(path, contents).with_context(|| format!("failed to write {}", path.display()))?;
    Ok(())
}

fn escape_literal(value: &str) -> String {
    value.chars().flat_map(|c| c.escape_default()).collect()
}
