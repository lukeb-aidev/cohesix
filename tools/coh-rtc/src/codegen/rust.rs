// Copyright Â© 2025 Lukas Bower
// SPDX-License-Identifier: Apache-2.0
// Purpose: Emit deterministic Rust bootstrap tables for the root task.
// Author: Lukas Bower

use crate::codegen::hash_bytes;
use crate::ir::{resolve_manifest_relative_path, HostProvider, Manifest, Role, SidecarLink};
use anyhow::{Context, Result};
use serde::Serialize;
use std::collections::BTreeSet;
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

pub fn emit_rust(
    manifest: &Manifest,
    manifest_hash: &str,
    out_dir: &Path,
    manifest_dir: Option<&Path>,
) -> Result<()> {
    let mod_rs = out_dir.join("mod.rs");
    let bootstrap_rs = out_dir.join("bootstrap.rs");

    let mut mod_contents = String::new();
    writeln!(mod_contents, "// Author: Lukas Bower")?;
    writeln!(
        mod_contents,
        "// Purpose: Generated root-task manifest tables and helpers."
    )?;
    writeln!(mod_contents, "// @generated by coh-rtc; do not edit.")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#![allow(clippy::all)]")?;
    writeln!(mod_contents, "#![allow(dead_code)]")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "use cohesix_ticket::Role;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "mod bootstrap;")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TicketSpec {{")?;
    writeln!(mod_contents, "    pub role: Role,")?;
    writeln!(mod_contents, "    pub secret: &'static str,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct NamespaceMount {{")?;
    writeln!(mod_contents, "    pub service: &'static str,")?;
    writeln!(mod_contents, "    pub target: &'static [&'static str],")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct CachePolicy {{")?;
    writeln!(mod_contents, "    pub kernel_ops: bool,")?;
    writeln!(mod_contents, "    pub dma_clean: bool,")?;
    writeln!(mod_contents, "    pub dma_invalidate: bool,")?;
    writeln!(mod_contents, "    pub unify_instructions: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub enum ShortWritePolicy {{")?;
    writeln!(mod_contents, "    Reject,")?;
    writeln!(mod_contents, "    Retry,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct Secure9pLimits {{")?;
    writeln!(mod_contents, "    pub msize: u32,")?;
    writeln!(mod_contents, "    pub walk_depth: u8,")?;
    writeln!(mod_contents, "    pub tags_per_session: u16,")?;
    writeln!(mod_contents, "    pub batch_frames: u16,")?;
    writeln!(
        mod_contents,
        "    pub short_write_policy: ShortWritePolicy,"
    )?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TicketLimits {{")?;
    writeln!(mod_contents, "    pub max_scopes: u16,")?;
    writeln!(mod_contents, "    pub max_scope_path_len: u16,")?;
    writeln!(mod_contents, "    pub max_scope_rate_per_s: u32,")?;
    writeln!(mod_contents, "    pub bandwidth_bytes: u64,")?;
    writeln!(mod_contents, "    pub cursor_resumes: u32,")?;
    writeln!(mod_contents, "    pub cursor_advances: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct ShardingConfig {{")?;
    writeln!(mod_contents, "    pub enabled: bool,")?;
    writeln!(mod_contents, "    pub shard_bits: u8,")?;
    writeln!(mod_contents, "    pub legacy_worker_alias: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub enum TelemetryFrameSchema {{")?;
    writeln!(mod_contents, "    LegacyPlaintext,")?;
    writeln!(mod_contents, "    CborV1,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TelemetryCursorConfig {{")?;
    writeln!(mod_contents, "    pub retain_on_boot: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TelemetryConfig {{")?;
    writeln!(mod_contents, "    pub ring_bytes_per_worker: u32,")?;
    writeln!(mod_contents, "    pub frame_schema: TelemetryFrameSchema,")?;
    writeln!(mod_contents, "    pub cursor: TelemetryCursorConfig,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub enum TelemetryIngestEvictionPolicy {{")?;
    writeln!(mod_contents, "    Refuse,")?;
    writeln!(mod_contents, "    EvictOldest,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct TelemetryIngestConfig {{")?;
    writeln!(mod_contents, "    pub max_segments_per_device: u32,")?;
    writeln!(mod_contents, "    pub max_bytes_per_segment: u32,")?;
    writeln!(mod_contents, "    pub max_total_bytes_per_device: u32,")?;
    writeln!(
        mod_contents,
        "    pub eviction_policy: TelemetryIngestEvictionPolicy,"
    )?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug, PartialEq, Eq)]")?;
    writeln!(mod_contents, "pub enum LifecycleState {{")?;
    writeln!(mod_contents, "    Booting,")?;
    writeln!(mod_contents, "    Degraded,")?;
    writeln!(mod_contents, "    Online,")?;
    writeln!(mod_contents, "    Draining,")?;
    writeln!(mod_contents, "    Quiesced,")?;
    writeln!(mod_contents, "    Offline,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct LifecycleAutoTransition {{")?;
    writeln!(mod_contents, "    pub from: LifecycleState,")?;
    writeln!(mod_contents, "    pub to: LifecycleState,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct LifecycleConfig {{")?;
    writeln!(mod_contents, "    pub initial_state: LifecycleState,")?;
    writeln!(
        mod_contents,
        "    pub auto_transitions: &'static [LifecycleAutoTransition],"
    )?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct CasConfig {{")?;
    writeln!(mod_contents, "    pub enable: bool,")?;
    writeln!(mod_contents, "    pub chunk_bytes: u32,")?;
    writeln!(mod_contents, "    pub delta_enable: bool,")?;
    writeln!(mod_contents, "    pub signing_required: bool,")?;
    writeln!(mod_contents, "    pub signing_key: Option<[u8; 32]>,")?;
    writeln!(mod_contents, "    pub models_enabled: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct Proc9pConfig {{")?;
    writeln!(mod_contents, "    pub sessions: bool,")?;
    writeln!(mod_contents, "    pub outstanding: bool,")?;
    writeln!(mod_contents, "    pub short_writes: bool,")?;
    writeln!(mod_contents, "    pub sessions_bytes: u32,")?;
    writeln!(mod_contents, "    pub outstanding_bytes: u32,")?;
    writeln!(mod_contents, "    pub short_writes_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct Proc9pSessionConfig {{")?;
    writeln!(mod_contents, "    pub active: bool,")?;
    writeln!(mod_contents, "    pub state: bool,")?;
    writeln!(mod_contents, "    pub since_ms: bool,")?;
    writeln!(mod_contents, "    pub owner: bool,")?;
    writeln!(mod_contents, "    pub active_bytes: u32,")?;
    writeln!(mod_contents, "    pub state_bytes: u32,")?;
    writeln!(mod_contents, "    pub since_ms_bytes: u32,")?;
    writeln!(mod_contents, "    pub owner_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct ProcIngestConfig {{")?;
    writeln!(mod_contents, "    pub p50_ms: bool,")?;
    writeln!(mod_contents, "    pub p95_ms: bool,")?;
    writeln!(mod_contents, "    pub backpressure: bool,")?;
    writeln!(mod_contents, "    pub dropped: bool,")?;
    writeln!(mod_contents, "    pub queued: bool,")?;
    writeln!(mod_contents, "    pub watch: bool,")?;
    writeln!(mod_contents, "    pub p50_ms_bytes: u32,")?;
    writeln!(mod_contents, "    pub p95_ms_bytes: u32,")?;
    writeln!(mod_contents, "    pub backpressure_bytes: u32,")?;
    writeln!(mod_contents, "    pub dropped_bytes: u32,")?;
    writeln!(mod_contents, "    pub queued_bytes: u32,")?;
    writeln!(mod_contents, "    pub watch_max_entries: u16,")?;
    writeln!(mod_contents, "    pub watch_line_bytes: u32,")?;
    writeln!(mod_contents, "    pub watch_min_interval_ms: u64,")?;
    writeln!(mod_contents, "    pub latency_samples: u16,")?;
    writeln!(mod_contents, "    pub latency_tolerance_ms: u32,")?;
    writeln!(mod_contents, "    pub counter_tolerance: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct ProcRootConfig {{")?;
    writeln!(mod_contents, "    pub reachable: bool,")?;
    writeln!(mod_contents, "    pub last_seen_ms: bool,")?;
    writeln!(mod_contents, "    pub cut_reason: bool,")?;
    writeln!(mod_contents, "    pub reachable_bytes: u32,")?;
    writeln!(mod_contents, "    pub last_seen_ms_bytes: u32,")?;
    writeln!(mod_contents, "    pub cut_reason_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct ProcPressureConfig {{")?;
    writeln!(mod_contents, "    pub busy: bool,")?;
    writeln!(mod_contents, "    pub quota: bool,")?;
    writeln!(mod_contents, "    pub cut: bool,")?;
    writeln!(mod_contents, "    pub policy: bool,")?;
    writeln!(mod_contents, "    pub busy_bytes: u32,")?;
    writeln!(mod_contents, "    pub quota_bytes: u32,")?;
    writeln!(mod_contents, "    pub cut_bytes: u32,")?;
    writeln!(mod_contents, "    pub policy_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct ObservabilityConfig {{")?;
    writeln!(mod_contents, "    pub proc_9p: Proc9pConfig,")?;
    writeln!(
        mod_contents,
        "    pub proc_9p_session: Proc9pSessionConfig,"
    )?;
    writeln!(mod_contents, "    pub proc_ingest: ProcIngestConfig,")?;
    writeln!(mod_contents, "    pub proc_root: ProcRootConfig,")?;
    writeln!(mod_contents, "    pub proc_pressure: ProcPressureConfig,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct UiProc9pConfig {{")?;
    writeln!(mod_contents, "    pub sessions: bool,")?;
    writeln!(mod_contents, "    pub outstanding: bool,")?;
    writeln!(mod_contents, "    pub short_writes: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct UiProcIngestConfig {{")?;
    writeln!(mod_contents, "    pub p50_ms: bool,")?;
    writeln!(mod_contents, "    pub p95_ms: bool,")?;
    writeln!(mod_contents, "    pub backpressure: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct UiPolicyPreflightConfig {{")?;
    writeln!(mod_contents, "    pub req: bool,")?;
    writeln!(mod_contents, "    pub diff: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct UiUpdatesConfig {{")?;
    writeln!(mod_contents, "    pub manifest: bool,")?;
    writeln!(mod_contents, "    pub status: bool,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct UiProviderConfig {{")?;
    writeln!(mod_contents, "    pub proc_9p: UiProc9pConfig,")?;
    writeln!(mod_contents, "    pub proc_ingest: UiProcIngestConfig,")?;
    writeln!(
        mod_contents,
        "    pub policy_preflight: UiPolicyPreflightConfig,"
    )?;
    writeln!(mod_contents, "    pub updates: UiUpdatesConfig,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug, PartialEq, Eq)]")?;
    writeln!(mod_contents, "pub enum HostProvider {{")?;
    writeln!(mod_contents, "    Systemd,")?;
    writeln!(mod_contents, "    K8s,")?;
    writeln!(mod_contents, "    Nvidia,")?;
    writeln!(mod_contents, "    Jetson,")?;
    writeln!(mod_contents, "    Net,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct HostConfig {{")?;
    writeln!(mod_contents, "    pub enable: bool,")?;
    writeln!(mod_contents, "    pub mount_at: &'static str,")?;
    writeln!(mod_contents, "    pub providers: &'static [HostProvider],")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub enum SidecarLink {{")?;
    writeln!(mod_contents, "    Serial,")?;
    writeln!(mod_contents, "    Tcp,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct SpoolConfig {{")?;
    writeln!(mod_contents, "    pub max_entries: u16,")?;
    writeln!(mod_contents, "    pub max_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct SidecarBusAdapter {{")?;
    writeln!(mod_contents, "    pub id: &'static str,")?;
    writeln!(mod_contents, "    pub mount: &'static str,")?;
    writeln!(mod_contents, "    pub scope: &'static str,")?;
    writeln!(mod_contents, "    pub link: SidecarLink,")?;
    writeln!(mod_contents, "    pub baud: u32,")?;
    writeln!(mod_contents, "    pub spool: SpoolConfig,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct SidecarBusConfig {{")?;
    writeln!(mod_contents, "    pub enable: bool,")?;
    writeln!(mod_contents, "    pub mount_at: &'static str,")?;
    writeln!(
        mod_contents,
        "    pub adapters: &'static [SidecarBusAdapter],"
    )?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct SidecarLoraAdapter {{")?;
    writeln!(mod_contents, "    pub id: &'static str,")?;
    writeln!(mod_contents, "    pub mount: &'static str,")?;
    writeln!(mod_contents, "    pub scope: &'static str,")?;
    writeln!(mod_contents, "    pub region: &'static str,")?;
    writeln!(mod_contents, "    pub duty_cycle_percent: u8,")?;
    writeln!(mod_contents, "    pub window_ms: u64,")?;
    writeln!(mod_contents, "    pub max_payload_bytes: u32,")?;
    writeln!(mod_contents, "    pub tamper_log_max_entries: u16,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct SidecarLoraConfig {{")?;
    writeln!(mod_contents, "    pub enable: bool,")?;
    writeln!(mod_contents, "    pub mount_at: &'static str,")?;
    writeln!(
        mod_contents,
        "    pub adapters: &'static [SidecarLoraAdapter],"
    )?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct SidecarConfig {{")?;
    writeln!(mod_contents, "    pub modbus: SidecarBusConfig,")?;
    writeln!(mod_contents, "    pub dnp3: SidecarBusConfig,")?;
    writeln!(mod_contents, "    pub lora: SidecarLoraConfig,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct PolicyRule {{")?;
    writeln!(mod_contents, "    pub id: &'static str,")?;
    writeln!(mod_contents, "    pub target: &'static str,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct PolicyLimits {{")?;
    writeln!(mod_contents, "    pub queue_max_entries: u16,")?;
    writeln!(mod_contents, "    pub queue_max_bytes: u32,")?;
    writeln!(mod_contents, "    pub ctl_max_bytes: u32,")?;
    writeln!(mod_contents, "    pub status_max_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct PolicyConfig {{")?;
    writeln!(mod_contents, "    pub enable: bool,")?;
    writeln!(mod_contents, "    pub limits: PolicyLimits,")?;
    writeln!(mod_contents, "    pub rules: &'static [PolicyRule],")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "#[derive(Clone, Copy, Debug)]")?;
    writeln!(mod_contents, "pub struct AuditConfig {{")?;
    writeln!(mod_contents, "    pub enable: bool,")?;
    writeln!(mod_contents, "    pub journal_max_bytes: u32,")?;
    writeln!(mod_contents, "    pub decisions_max_bytes: u32,")?;
    writeln!(mod_contents, "    pub replay_enable: bool,")?;
    writeln!(mod_contents, "    pub replay_max_entries: u16,")?;
    writeln!(mod_contents, "    pub replay_ctl_max_bytes: u32,")?;
    writeln!(mod_contents, "    pub replay_status_max_bytes: u32,")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const MANIFEST_SCHEMA: &str = \"{}\";",
        manifest.root_task.schema
    )?;
    writeln!(
        mod_contents,
        "pub const MANIFEST_SHA256: &str = \"{}\";",
        manifest_hash
    )?;
    writeln!(
        mod_contents,
        "pub const TICKET_TABLE_SHA256: &str = bootstrap::TICKET_TABLE_SHA256;"
    )?;
    writeln!(
        mod_contents,
        "pub const NAMESPACE_TABLE_SHA256: &str = bootstrap::NAMESPACE_TABLE_SHA256;"
    )?;
    writeln!(
        mod_contents,
        "pub const AUDIT_TABLE_SHA256: &str = bootstrap::AUDIT_TABLE_SHA256;"
    )?;
    writeln!(
        mod_contents,
        "pub const CACHE_POLICY: CachePolicy = bootstrap::CACHE_POLICY;"
    )?;
    writeln!(
        mod_contents,
        "pub const SECURE9P_LIMITS: Secure9pLimits = bootstrap::SECURE9P_LIMITS;"
    )?;
    writeln!(
        mod_contents,
        "pub const TICKET_LIMITS: TicketLimits = bootstrap::TICKET_LIMITS;"
    )?;
    writeln!(
        mod_contents,
        "pub const SHARDING_CONFIG: ShardingConfig = bootstrap::SHARDING_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const SHARD_COUNT: usize = bootstrap::SHARD_LABELS.len();"
    )?;
    writeln!(
        mod_contents,
        "pub const TELEMETRY_CONFIG: TelemetryConfig = bootstrap::TELEMETRY_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const TELEMETRY_INGEST_CONFIG: TelemetryIngestConfig = bootstrap::TELEMETRY_INGEST_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const LIFECYCLE_CONFIG: LifecycleConfig = bootstrap::LIFECYCLE_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const OBSERVABILITY_CONFIG: ObservabilityConfig = bootstrap::OBSERVABILITY_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const UI_PROVIDER_CONFIG: UiProviderConfig = bootstrap::UI_PROVIDER_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const CAS_CONFIG: CasConfig = bootstrap::CAS_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_9P_SESSIONS_BYTES: usize = bootstrap::PROC_9P_SESSIONS_BYTES;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_9P_OUTSTANDING_BYTES: usize = bootstrap::PROC_9P_OUTSTANDING_BYTES;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_9P_SHORT_WRITES_BYTES: usize = bootstrap::PROC_9P_SHORT_WRITES_BYTES;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_INGEST_P50_BYTES: usize = bootstrap::PROC_INGEST_P50_BYTES;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_INGEST_P95_BYTES: usize = bootstrap::PROC_INGEST_P95_BYTES;"
    )?;
    writeln!(mod_contents, "pub const PROC_INGEST_BACKPRESSURE_BYTES: usize = bootstrap::PROC_INGEST_BACKPRESSURE_BYTES;")?;
    writeln!(
        mod_contents,
        "pub const PROC_INGEST_DROPPED_BYTES: usize = bootstrap::PROC_INGEST_DROPPED_BYTES;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_INGEST_QUEUED_BYTES: usize = bootstrap::PROC_INGEST_QUEUED_BYTES;"
    )?;
    writeln!(mod_contents, "pub const PROC_INGEST_WATCH_MAX_ENTRIES: usize = bootstrap::PROC_INGEST_WATCH_MAX_ENTRIES;")?;
    writeln!(
        mod_contents,
        "pub const PROC_INGEST_WATCH_LINE_BYTES: usize = bootstrap::PROC_INGEST_WATCH_LINE_BYTES;"
    )?;
    writeln!(
        mod_contents,
        "pub const PROC_INGEST_LATENCY_SAMPLES: usize = bootstrap::PROC_INGEST_LATENCY_SAMPLES;"
    )?;
    writeln!(
        mod_contents,
        "pub const HOST_CONFIG: HostConfig = bootstrap::HOST_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const SIDECAR_CONFIG: SidecarConfig = bootstrap::SIDECAR_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const POLICY_CONFIG: PolicyConfig = bootstrap::POLICY_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const POLICY_RULES_JSON: &str = bootstrap::POLICY_RULES_JSON;"
    )?;
    writeln!(
        mod_contents,
        "pub const AUDIT_CONFIG: AuditConfig = bootstrap::AUDIT_CONFIG;"
    )?;
    writeln!(
        mod_contents,
        "pub const EVENT_PUMP_FDS: &[&str] = &bootstrap::EVENT_PUMP_FDS;"
    )?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn ticket_inventory() -> &'static [TicketSpec] {{"
    )?;
    writeln!(mod_contents, "    &bootstrap::TICKET_INVENTORY")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn namespace_mounts() -> &'static [NamespaceMount] {{"
    )?;
    writeln!(mod_contents, "    &bootstrap::NAMESPACE_MOUNTS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn initial_audit_lines() -> &'static [&'static str] {{"
    )?;
    writeln!(mod_contents, "    &bootstrap::INITIAL_AUDIT_LINES")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn cache_policy() -> CachePolicy {{"
    )?;
    writeln!(mod_contents, "    bootstrap::CACHE_POLICY")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn secure9p_limits() -> Secure9pLimits {{"
    )?;
    writeln!(mod_contents, "    bootstrap::SECURE9P_LIMITS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn ticket_limits() -> TicketLimits {{"
    )?;
    writeln!(mod_contents, "    bootstrap::TICKET_LIMITS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn sharding_config() -> ShardingConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::SHARDING_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn shard_labels() -> &'static [&'static str] {{"
    )?;
    writeln!(mod_contents, "    &bootstrap::SHARD_LABELS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn telemetry_config() -> TelemetryConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::TELEMETRY_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn telemetry_ingest_config() -> TelemetryIngestConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::TELEMETRY_INGEST_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn lifecycle_config() -> LifecycleConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::LIFECYCLE_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn observability_config() -> ObservabilityConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::OBSERVABILITY_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn ui_provider_config() -> UiProviderConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::UI_PROVIDER_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn cas_config() -> CasConfig {{")?;
    writeln!(mod_contents, "    bootstrap::CAS_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(mod_contents, "pub const fn host_config() -> HostConfig {{")?;
    writeln!(mod_contents, "    bootstrap::HOST_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn sidecar_config() -> SidecarConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::SIDECAR_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn policy_config() -> PolicyConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::POLICY_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn policy_rules_json() -> &'static str {{"
    )?;
    writeln!(mod_contents, "    bootstrap::POLICY_RULES_JSON")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn audit_config() -> AuditConfig {{"
    )?;
    writeln!(mod_contents, "    bootstrap::AUDIT_CONFIG")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const fn event_pump_fds() -> &'static [&'static str] {{"
    )?;
    writeln!(mod_contents, "    &bootstrap::EVENT_PUMP_FDS")?;
    writeln!(mod_contents, "}}")?;
    writeln!(mod_contents)?;
    writeln!(
        mod_contents,
        "pub const TICKET_COUNT: usize = bootstrap::TICKET_INVENTORY.len();"
    )?;

    let ticket_hash = hash_bytes(
        serde_json::to_vec(&manifest.tickets)
            .context("serialize tickets")?
            .as_slice(),
    );
    let namespace_hash = hash_bytes(
        serde_json::to_vec(&manifest.namespaces.mounts)
            .context("serialize namespaces")?
            .as_slice(),
    );

    let event_pump_fds = build_event_pump_fds(manifest);
    let audit_lines = build_audit_lines(manifest, manifest_hash, &event_pump_fds);
    let audit_hash = hash_bytes(
        serde_json::to_vec(&audit_lines)
            .context("serialize audit lines")?
            .as_slice(),
    );
    let policy_rules_json = render_policy_rules_json(manifest)?;
    let cas_signing_required = manifest
        .cas
        .signing
        .as_ref()
        .map(|signing| signing.required)
        .unwrap_or(false);
    let cas_signing_key = cas_signing_key_literal(manifest, manifest_dir)?;

    let mut bootstrap_contents = String::new();
    writeln!(bootstrap_contents, "// Author: Lukas Bower")?;
    writeln!(
        bootstrap_contents,
        "// Purpose: Generated manifest tables for root-task bootstrap."
    )?;
    writeln!(bootstrap_contents, "// @generated by coh-rtc; do not edit.")?;
    writeln!(bootstrap_contents)?;
    writeln!(bootstrap_contents, "#![allow(unused_imports)]")?;
    writeln!(bootstrap_contents)?;
    writeln!(
        bootstrap_contents,
        "use super::{{AuditConfig, CachePolicy, CasConfig, HostConfig, HostProvider, LifecycleAutoTransition, LifecycleConfig, LifecycleState, NamespaceMount, ObservabilityConfig, PolicyConfig, PolicyLimits, PolicyRule, Proc9pConfig, Proc9pSessionConfig, ProcIngestConfig, ProcPressureConfig, ProcRootConfig, Secure9pLimits, ShardingConfig, ShortWritePolicy, SidecarBusAdapter, SidecarBusConfig, SidecarConfig, SidecarLink, SidecarLoraAdapter, SidecarLoraConfig, SpoolConfig, TelemetryConfig, TelemetryCursorConfig, TelemetryFrameSchema, TelemetryIngestConfig, TelemetryIngestEvictionPolicy, TicketLimits, TicketSpec, UiPolicyPreflightConfig, UiProc9pConfig, UiProcIngestConfig, UiProviderConfig, UiUpdatesConfig}};"
    )?;
    writeln!(bootstrap_contents, "use cohesix_ticket::Role;")?;
    writeln!(bootstrap_contents)?;
    writeln!(
        bootstrap_contents,
        "pub const TICKET_TABLE_SHA256: &str = \"{}\";",
        ticket_hash
    )?;
    writeln!(
        bootstrap_contents,
        "pub const NAMESPACE_TABLE_SHA256: &str = \"{}\";",
        namespace_hash
    )?;
    writeln!(
        bootstrap_contents,
        "pub const AUDIT_TABLE_SHA256: &str = \"{}\";",
        audit_hash
    )?;
    writeln!(bootstrap_contents)?;

    writeln!(
        bootstrap_contents,
        "pub const TICKET_INVENTORY: [TicketSpec; {}] = [",
        manifest.tickets.len()
    )?;
    for ticket in &manifest.tickets {
        writeln!(
            bootstrap_contents,
            "    TicketSpec {{ role: {}, secret: \"{}\" }},",
            role_to_rust(ticket.role),
            escape_literal(&ticket.secret)
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const NAMESPACE_MOUNTS: [NamespaceMount; {}] = [",
        manifest.namespaces.mounts.len()
    )?;
    for mount in &manifest.namespaces.mounts {
        let target = mount
            .target
            .iter()
            .map(|seg| format!("\"{}\"", escape_literal(seg)))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(
            bootstrap_contents,
            "    NamespaceMount {{ service: \"{}\", target: &[{}] }},",
            escape_literal(&mount.service),
            target
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const CACHE_POLICY: CachePolicy = CachePolicy {{ kernel_ops: {}, dma_clean: {}, dma_invalidate: {}, unify_instructions: {} }};\n",
        manifest.cache.kernel_ops,
        manifest.cache.dma_clean,
        manifest.cache.dma_invalidate,
        manifest.cache.unify_instructions
    )?;
    writeln!(
        bootstrap_contents,
        "pub const SECURE9P_LIMITS: Secure9pLimits = Secure9pLimits {{ msize: {}, walk_depth: {}, tags_per_session: {}, batch_frames: {}, short_write_policy: {} }};\n",
        manifest.secure9p.msize,
        manifest.secure9p.walk_depth,
        manifest.secure9p.tags_per_session,
        manifest.secure9p.batch_frames,
        short_write_policy_to_rust(&manifest.secure9p.short_write.policy)
    )?;
    writeln!(
        bootstrap_contents,
        "pub const TICKET_LIMITS: TicketLimits = TicketLimits {{ max_scopes: {}, max_scope_path_len: {}, max_scope_rate_per_s: {}, bandwidth_bytes: {}, cursor_resumes: {}, cursor_advances: {} }};\n",
        manifest.ticket_limits.max_scopes,
        manifest.ticket_limits.max_scope_path_len,
        manifest.ticket_limits.max_scope_rate_per_s,
        manifest.ticket_limits.bandwidth_bytes,
        manifest.ticket_limits.cursor_resumes,
        manifest.ticket_limits.cursor_advances
    )?;
    writeln!(
        bootstrap_contents,
        "pub const SHARDING_CONFIG: ShardingConfig = ShardingConfig {{ enabled: {}, shard_bits: {}, legacy_worker_alias: {} }};\n",
        manifest.sharding.enabled,
        manifest.sharding.shard_bits,
        manifest.sharding.legacy_worker_alias
    )?;
    let shard_labels = build_shard_labels(manifest);
    writeln!(
        bootstrap_contents,
        "pub const SHARD_LABELS: [&str; {}] = [",
        shard_labels.len()
    )?;
    for label in &shard_labels {
        writeln!(bootstrap_contents, "    \"{}\",", escape_literal(label))?;
    }
    writeln!(bootstrap_contents, "];\n")?;
    writeln!(
        bootstrap_contents,
        "pub const TELEMETRY_CONFIG: TelemetryConfig = TelemetryConfig {{ ring_bytes_per_worker: {}, frame_schema: {}, cursor: TelemetryCursorConfig {{ retain_on_boot: {} }} }};\n",
        manifest.telemetry.ring_bytes_per_worker,
        telemetry_schema_to_rust(&manifest.telemetry.frame_schema),
        manifest.telemetry.cursor.retain_on_boot
    )?;
    writeln!(
        bootstrap_contents,
        "pub const TELEMETRY_INGEST_CONFIG: TelemetryIngestConfig = TelemetryIngestConfig {{ max_segments_per_device: {}, max_bytes_per_segment: {}, max_total_bytes_per_device: {}, eviction_policy: {} }};\n",
        manifest.telemetry_ingest.max_segments_per_device,
        manifest.telemetry_ingest.max_bytes_per_segment,
        manifest.telemetry_ingest.max_total_bytes_per_device,
        ingest_eviction_policy_to_rust(&manifest.telemetry_ingest.eviction_policy)
    )?;
    writeln!(
        bootstrap_contents,
        "pub const LIFECYCLE_AUTO_TRANSITIONS: [LifecycleAutoTransition; {}] = [",
        manifest.lifecycle.auto_transitions.len()
    )?;
    for transition in &manifest.lifecycle.auto_transitions {
        writeln!(
            bootstrap_contents,
            "    LifecycleAutoTransition {{ from: {}, to: {} }},",
            lifecycle_state_to_rust(transition.from),
            lifecycle_state_to_rust(transition.to)
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;
    writeln!(
        bootstrap_contents,
        "pub const LIFECYCLE_CONFIG: LifecycleConfig = LifecycleConfig {{ initial_state: {}, auto_transitions: &LIFECYCLE_AUTO_TRANSITIONS }};\n",
        lifecycle_state_to_rust(manifest.lifecycle.initial_state)
    )?;
    writeln!(
        bootstrap_contents,
        "pub const CAS_CONFIG: CasConfig = CasConfig {{ enable: {}, chunk_bytes: {}, delta_enable: {}, signing_required: {}, signing_key: {}, models_enabled: {} }};\n",
        manifest.cas.enable,
        manifest.cas.store.chunk_bytes,
        manifest.cas.delta.enable,
        cas_signing_required,
        cas_signing_key,
        manifest.ecosystem.models.enable
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_SESSIONS_BYTES: usize = {};",
        manifest.observability.proc_9p.sessions_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_OUTSTANDING_BYTES: usize = {};",
        manifest.observability.proc_9p.outstanding_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_SHORT_WRITES_BYTES: usize = {};",
        manifest.observability.proc_9p.short_writes_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_SESSION_ACTIVE_BYTES: usize = {};",
        manifest.observability.proc_9p_session.active_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_SESSION_STATE_BYTES: usize = {};",
        manifest.observability.proc_9p_session.state_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_SESSION_SINCE_MS_BYTES: usize = {};",
        manifest.observability.proc_9p_session.since_ms_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_9P_SESSION_OWNER_BYTES: usize = {};",
        manifest.observability.proc_9p_session.owner_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_P50_BYTES: usize = {};",
        manifest.observability.proc_ingest.p50_ms_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_P95_BYTES: usize = {};",
        manifest.observability.proc_ingest.p95_ms_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_BACKPRESSURE_BYTES: usize = {};",
        manifest.observability.proc_ingest.backpressure_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_DROPPED_BYTES: usize = {};",
        manifest.observability.proc_ingest.dropped_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_QUEUED_BYTES: usize = {};",
        manifest.observability.proc_ingest.queued_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_WATCH_MAX_ENTRIES: usize = {};",
        manifest.observability.proc_ingest.watch_max_entries as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_WATCH_LINE_BYTES: usize = {};",
        manifest.observability.proc_ingest.watch_line_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_INGEST_LATENCY_SAMPLES: usize = {};",
        manifest.observability.proc_ingest.latency_samples as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_ROOT_REACHABLE_BYTES: usize = {};",
        manifest.observability.proc_root.reachable_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_ROOT_LAST_SEEN_MS_BYTES: usize = {};",
        manifest.observability.proc_root.last_seen_ms_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_ROOT_CUT_REASON_BYTES: usize = {};",
        manifest.observability.proc_root.cut_reason_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_PRESSURE_BUSY_BYTES: usize = {};",
        manifest.observability.proc_pressure.busy_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_PRESSURE_QUOTA_BYTES: usize = {};",
        manifest.observability.proc_pressure.quota_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_PRESSURE_CUT_BYTES: usize = {};",
        manifest.observability.proc_pressure.cut_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const PROC_PRESSURE_POLICY_BYTES: usize = {};",
        manifest.observability.proc_pressure.policy_bytes as usize
    )?;
    writeln!(
        bootstrap_contents,
        "pub const OBSERVABILITY_CONFIG: ObservabilityConfig = ObservabilityConfig {{ proc_9p: Proc9pConfig {{ sessions: {}, outstanding: {}, short_writes: {}, sessions_bytes: {}, outstanding_bytes: {}, short_writes_bytes: {} }}, proc_9p_session: Proc9pSessionConfig {{ active: {}, state: {}, since_ms: {}, owner: {}, active_bytes: {}, state_bytes: {}, since_ms_bytes: {}, owner_bytes: {} }}, proc_ingest: ProcIngestConfig {{ p50_ms: {}, p95_ms: {}, backpressure: {}, dropped: {}, queued: {}, watch: {}, p50_ms_bytes: {}, p95_ms_bytes: {}, backpressure_bytes: {}, dropped_bytes: {}, queued_bytes: {}, watch_max_entries: {}, watch_line_bytes: {}, watch_min_interval_ms: {}, latency_samples: {}, latency_tolerance_ms: {}, counter_tolerance: {} }}, proc_root: ProcRootConfig {{ reachable: {}, last_seen_ms: {}, cut_reason: {}, reachable_bytes: {}, last_seen_ms_bytes: {}, cut_reason_bytes: {} }}, proc_pressure: ProcPressureConfig {{ busy: {}, quota: {}, cut: {}, policy: {}, busy_bytes: {}, quota_bytes: {}, cut_bytes: {}, policy_bytes: {} }} }};\n",
        manifest.observability.proc_9p.sessions,
        manifest.observability.proc_9p.outstanding,
        manifest.observability.proc_9p.short_writes,
        manifest.observability.proc_9p.sessions_bytes,
        manifest.observability.proc_9p.outstanding_bytes,
        manifest.observability.proc_9p.short_writes_bytes,
        manifest.observability.proc_9p_session.active,
        manifest.observability.proc_9p_session.state,
        manifest.observability.proc_9p_session.since_ms,
        manifest.observability.proc_9p_session.owner,
        manifest.observability.proc_9p_session.active_bytes,
        manifest.observability.proc_9p_session.state_bytes,
        manifest.observability.proc_9p_session.since_ms_bytes,
        manifest.observability.proc_9p_session.owner_bytes,
        manifest.observability.proc_ingest.p50_ms,
        manifest.observability.proc_ingest.p95_ms,
        manifest.observability.proc_ingest.backpressure,
        manifest.observability.proc_ingest.dropped,
        manifest.observability.proc_ingest.queued,
        manifest.observability.proc_ingest.watch,
        manifest.observability.proc_ingest.p50_ms_bytes,
        manifest.observability.proc_ingest.p95_ms_bytes,
        manifest.observability.proc_ingest.backpressure_bytes,
        manifest.observability.proc_ingest.dropped_bytes,
        manifest.observability.proc_ingest.queued_bytes,
        manifest.observability.proc_ingest.watch_max_entries,
        manifest.observability.proc_ingest.watch_line_bytes,
        manifest.observability.proc_ingest.watch_min_interval_ms,
        manifest.observability.proc_ingest.latency_samples,
        manifest.observability.proc_ingest.latency_tolerance_ms,
        manifest.observability.proc_ingest.counter_tolerance,
        manifest.observability.proc_root.reachable,
        manifest.observability.proc_root.last_seen_ms,
        manifest.observability.proc_root.cut_reason,
        manifest.observability.proc_root.reachable_bytes,
        manifest.observability.proc_root.last_seen_ms_bytes,
        manifest.observability.proc_root.cut_reason_bytes,
        manifest.observability.proc_pressure.busy,
        manifest.observability.proc_pressure.quota,
        manifest.observability.proc_pressure.cut,
        manifest.observability.proc_pressure.policy,
        manifest.observability.proc_pressure.busy_bytes,
        manifest.observability.proc_pressure.quota_bytes,
        manifest.observability.proc_pressure.cut_bytes,
        manifest.observability.proc_pressure.policy_bytes
    )?;
    writeln!(
        bootstrap_contents,
        "pub const UI_PROVIDER_CONFIG: UiProviderConfig = UiProviderConfig {{ proc_9p: UiProc9pConfig {{ sessions: {}, outstanding: {}, short_writes: {} }}, proc_ingest: UiProcIngestConfig {{ p50_ms: {}, p95_ms: {}, backpressure: {} }}, policy_preflight: UiPolicyPreflightConfig {{ req: {}, diff: {} }}, updates: UiUpdatesConfig {{ manifest: {}, status: {} }} }};\n",
        manifest.ui_providers.proc_9p.sessions,
        manifest.ui_providers.proc_9p.outstanding,
        manifest.ui_providers.proc_9p.short_writes,
        manifest.ui_providers.proc_ingest.p50_ms,
        manifest.ui_providers.proc_ingest.p95_ms,
        manifest.ui_providers.proc_ingest.backpressure,
        manifest.ui_providers.policy_preflight.req,
        manifest.ui_providers.policy_preflight.diff,
        manifest.ui_providers.updates.manifest,
        manifest.ui_providers.updates.status
    )?;
    writeln!(
        bootstrap_contents,
        "pub const HOST_PROVIDERS: [HostProvider; {}] = [",
        manifest.ecosystem.host.providers.len()
    )?;
    for provider in &manifest.ecosystem.host.providers {
        writeln!(
            bootstrap_contents,
            "    {},",
            host_provider_to_rust(provider)
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;
    writeln!(
        bootstrap_contents,
        "pub const HOST_CONFIG: HostConfig = HostConfig {{ enable: {}, mount_at: \"{}\", providers: &HOST_PROVIDERS }};\n",
        manifest.ecosystem.host.enable,
        escape_literal(&manifest.ecosystem.host.mount_at)
    )?;

    let (modbus_adapters, dnp3_adapters) = resolve_bus_adapters(manifest)?;
    let lora_adapters = resolve_lora_adapters(manifest)?;

    writeln!(
        bootstrap_contents,
        "pub const MODBUS_ADAPTERS: [SidecarBusAdapter; {}] = [",
        modbus_adapters.len()
    )?;
    for adapter in &modbus_adapters {
        writeln!(
            bootstrap_contents,
            "    SidecarBusAdapter {{ id: \"{}\", mount: \"{}\", scope: \"{}\", link: {}, baud: {}, spool: SpoolConfig {{ max_entries: {}, max_bytes: {} }} }},",
            escape_literal(adapter.id),
            escape_literal(&adapter.mount),
            escape_literal(adapter.scope),
            sidecar_link_to_rust(adapter.link),
            adapter.baud,
            adapter.spool.max_entries,
            adapter.spool.max_bytes
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const DNP3_ADAPTERS: [SidecarBusAdapter; {}] = [",
        dnp3_adapters.len()
    )?;
    for adapter in &dnp3_adapters {
        writeln!(
            bootstrap_contents,
            "    SidecarBusAdapter {{ id: \"{}\", mount: \"{}\", scope: \"{}\", link: {}, baud: {}, spool: SpoolConfig {{ max_entries: {}, max_bytes: {} }} }},",
            escape_literal(adapter.id),
            escape_literal(&adapter.mount),
            escape_literal(adapter.scope),
            sidecar_link_to_rust(adapter.link),
            adapter.baud,
            adapter.spool.max_entries,
            adapter.spool.max_bytes
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const LORA_ADAPTERS: [SidecarLoraAdapter; {}] = [",
        lora_adapters.len()
    )?;
    for adapter in &lora_adapters {
        writeln!(
            bootstrap_contents,
            "    SidecarLoraAdapter {{ id: \"{}\", mount: \"{}\", scope: \"{}\", region: \"{}\", duty_cycle_percent: {}, window_ms: {}, max_payload_bytes: {}, tamper_log_max_entries: {} }},",
            escape_literal(adapter.id),
            escape_literal(&adapter.mount),
            escape_literal(adapter.scope),
            escape_literal(&adapter.region),
            adapter.duty_cycle_percent,
            adapter.window_ms,
            adapter.max_payload_bytes,
            adapter.tamper_log_max_entries
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const SIDECAR_CONFIG: SidecarConfig = SidecarConfig {{ modbus: SidecarBusConfig {{ enable: {}, mount_at: \"{}\", adapters: &MODBUS_ADAPTERS }}, dnp3: SidecarBusConfig {{ enable: {}, mount_at: \"{}\", adapters: &DNP3_ADAPTERS }}, lora: SidecarLoraConfig {{ enable: {}, mount_at: \"{}\", adapters: &LORA_ADAPTERS }} }};\n",
        manifest.sidecars.modbus.enable,
        escape_literal(&manifest.sidecars.modbus.mount_at),
        manifest.sidecars.dnp3.enable,
        escape_literal(&manifest.sidecars.dnp3.mount_at),
        manifest.sidecars.lora.enable,
        escape_literal(&manifest.sidecars.lora.mount_at)
    )?;
    writeln!(
        bootstrap_contents,
        "pub const POLICY_RULES: [PolicyRule; {}] = [",
        manifest.ecosystem.policy.rules.len()
    )?;
    for rule in &manifest.ecosystem.policy.rules {
        writeln!(
            bootstrap_contents,
            "    PolicyRule {{ id: \"{}\", target: \"{}\" }},",
            escape_literal(&rule.id),
            escape_literal(&rule.target)
        )?;
    }
    writeln!(bootstrap_contents, "];\n")?;
    writeln!(
        bootstrap_contents,
        "pub const POLICY_CONFIG: PolicyConfig = PolicyConfig {{ enable: {}, limits: PolicyLimits {{ queue_max_entries: {}, queue_max_bytes: {}, ctl_max_bytes: {}, status_max_bytes: {} }}, rules: &POLICY_RULES }};\n",
        manifest.ecosystem.policy.enable,
        manifest.ecosystem.policy.queue_max_entries,
        manifest.ecosystem.policy.queue_max_bytes,
        manifest.ecosystem.policy.ctl_max_bytes,
        manifest.ecosystem.policy.status_max_bytes
    )?;
    writeln!(
        bootstrap_contents,
        "pub const POLICY_RULES_JSON: &str = \"{}\";\n",
        escape_literal(&policy_rules_json)
    )?;
    writeln!(
        bootstrap_contents,
        "pub const AUDIT_CONFIG: AuditConfig = AuditConfig {{ enable: {}, journal_max_bytes: {}, decisions_max_bytes: {}, replay_enable: {}, replay_max_entries: {}, replay_ctl_max_bytes: {}, replay_status_max_bytes: {} }};\n",
        manifest.ecosystem.audit.enable,
        manifest.ecosystem.audit.journal_max_bytes,
        manifest.ecosystem.audit.decisions_max_bytes,
        manifest.ecosystem.audit.replay_enable,
        manifest.ecosystem.audit.replay_max_entries,
        manifest.ecosystem.audit.replay_ctl_max_bytes,
        manifest.ecosystem.audit.replay_status_max_bytes
    )?;
    writeln!(
        bootstrap_contents,
        "pub const EVENT_PUMP_FDS: [&str; {}] = [",
        event_pump_fds.len()
    )?;
    for fd in &event_pump_fds {
        writeln!(bootstrap_contents, "    \"{}\",", escape_literal(fd))?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    writeln!(
        bootstrap_contents,
        "pub const INITIAL_AUDIT_LINES: [&str; {}] = [",
        audit_lines.len()
    )?;
    for line in &audit_lines {
        writeln!(bootstrap_contents, "    \"{}\",", escape_literal(line))?;
    }
    writeln!(bootstrap_contents, "];\n")?;

    write_if_changed(&mod_rs, &mod_contents)?;
    write_if_changed(&bootstrap_rs, &bootstrap_contents)?;

    Ok(())
}

fn role_to_rust(role: Role) -> &'static str {
    match role {
        Role::Queen => "Role::Queen",
        Role::WorkerHeartbeat => "Role::WorkerHeartbeat",
        Role::WorkerGpu => "Role::WorkerGpu",
        Role::WorkerBus => "Role::WorkerBus",
        Role::WorkerLora => "Role::WorkerLora",
    }
}

fn host_provider_to_rust(provider: &HostProvider) -> &'static str {
    match provider {
        HostProvider::Systemd => "HostProvider::Systemd",
        HostProvider::K8s => "HostProvider::K8s",
        HostProvider::Nvidia => "HostProvider::Nvidia",
        HostProvider::Jetson => "HostProvider::Jetson",
        HostProvider::Net => "HostProvider::Net",
    }
}

struct ResolvedSidecarBusAdapter<'a> {
    id: &'a str,
    mount: String,
    scope: &'a str,
    link: SidecarLink,
    baud: u32,
    spool: &'a crate::ir::SpoolConfig,
}

struct ResolvedSidecarLoraAdapter<'a> {
    id: &'a str,
    mount: String,
    scope: &'a str,
    region: &'a str,
    duty_cycle_percent: u8,
    window_ms: u64,
    max_payload_bytes: u32,
    tamper_log_max_entries: u16,
}

fn resolve_bus_adapters(
    manifest: &Manifest,
) -> Result<(
    Vec<ResolvedSidecarBusAdapter<'_>>,
    Vec<ResolvedSidecarBusAdapter<'_>>,
)> {
    let mut used = sidecar_reserved_names();
    let modbus = resolve_sidecar_bus("modbus", &manifest.sidecars.modbus, &mut used)?;
    let dnp3 = resolve_sidecar_bus("dnp3", &manifest.sidecars.dnp3, &mut used)?;
    Ok((modbus, dnp3))
}

fn resolve_lora_adapters(manifest: &Manifest) -> Result<Vec<ResolvedSidecarLoraAdapter<'_>>> {
    let mut used = sidecar_reserved_names();
    resolve_sidecar_lora(&manifest.sidecars.lora, &mut used)
}

fn resolve_sidecar_bus<'a>(
    kind: &str,
    config: &'a crate::ir::SidecarBusConfig,
    used: &mut BTreeSet<String>,
) -> Result<Vec<ResolvedSidecarBusAdapter<'a>>> {
    if !config.enable {
        return Ok(Vec::new());
    }
    let mut resolved = Vec::new();
    for adapter in &config.adapters {
        let mount = resolve_sidecar_mount(kind, &adapter.id, &adapter.mount, used)?;
        resolved.push(ResolvedSidecarBusAdapter {
            id: adapter.id.as_str(),
            mount,
            scope: adapter.scope.as_str(),
            link: adapter.link,
            baud: adapter.baud,
            spool: &adapter.spool,
        });
    }
    Ok(resolved)
}

fn resolve_sidecar_lora<'a>(
    config: &'a crate::ir::SidecarLoraConfig,
    used: &mut BTreeSet<String>,
) -> Result<Vec<ResolvedSidecarLoraAdapter<'a>>> {
    if !config.enable {
        return Ok(Vec::new());
    }
    let mut resolved = Vec::new();
    for adapter in &config.adapters {
        let mount = resolve_sidecar_mount("lora", &adapter.id, &adapter.mount, used)?;
        resolved.push(ResolvedSidecarLoraAdapter {
            id: adapter.id.as_str(),
            mount,
            scope: adapter.scope.as_str(),
            region: adapter.region.as_str(),
            duty_cycle_percent: adapter.duty_cycle_percent,
            window_ms: adapter.window_ms,
            max_payload_bytes: adapter.max_payload_bytes,
            tamper_log_max_entries: adapter.tamper_log_max_entries,
        });
    }
    Ok(resolved)
}

fn resolve_sidecar_mount(
    kind: &str,
    adapter_id: &str,
    mount: &str,
    used: &mut BTreeSet<String>,
) -> Result<String> {
    let mut label = mount.to_owned();
    if used.contains(&label) {
        label = hashed_sidecar_label(kind, adapter_id, mount);
    }
    if used.contains(&label) {
        return Err(anyhow::anyhow!(
            "sidecar {kind} mount '{}' collides after hashing",
            mount
        ));
    }
    if label.len() > 255 {
        return Err(anyhow::anyhow!(
            "sidecar {kind} mount '{}' exceeds max component length 255",
            label
        ));
    }
    used.insert(label.clone());
    Ok(label)
}

fn hashed_sidecar_label(kind: &str, adapter_id: &str, mount: &str) -> String {
    let seed = format!("{kind}:{adapter_id}:{mount}");
    let digest = hash_bytes(seed.as_bytes());
    let prefix = digest.get(0..8).unwrap_or("00000000");
    format!("{prefix}-{mount}")
}

fn sidecar_reserved_names() -> BTreeSet<String> {
    [
        "proc", "log", "queen", "worker", "shard", "gpu", "host", "policy", "actions", "audit",
        "replay", "updates", "models", "trace", "kmesg", "bus", "lora",
    ]
    .iter()
    .map(|entry| entry.to_string())
    .collect()
}

fn sidecar_link_to_rust(link: SidecarLink) -> &'static str {
    match link {
        SidecarLink::Serial => "SidecarLink::Serial",
        SidecarLink::Tcp => "SidecarLink::Tcp",
    }
}

fn short_write_policy_to_rust(policy: &crate::ir::ShortWritePolicy) -> &'static str {
    match policy {
        crate::ir::ShortWritePolicy::Reject => "ShortWritePolicy::Reject",
        crate::ir::ShortWritePolicy::Retry => "ShortWritePolicy::Retry",
    }
}

fn short_write_policy_label(policy: &crate::ir::ShortWritePolicy) -> &'static str {
    match policy {
        crate::ir::ShortWritePolicy::Reject => "reject",
        crate::ir::ShortWritePolicy::Retry => "retry",
    }
}

fn telemetry_schema_to_rust(schema: &crate::ir::TelemetryFrameSchema) -> &'static str {
    match schema {
        crate::ir::TelemetryFrameSchema::LegacyPlaintext => "TelemetryFrameSchema::LegacyPlaintext",
        crate::ir::TelemetryFrameSchema::CborV1 => "TelemetryFrameSchema::CborV1",
    }
}

fn lifecycle_state_to_rust(state: crate::ir::LifecycleState) -> &'static str {
    match state {
        crate::ir::LifecycleState::Booting => "LifecycleState::Booting",
        crate::ir::LifecycleState::Degraded => "LifecycleState::Degraded",
        crate::ir::LifecycleState::Online => "LifecycleState::Online",
        crate::ir::LifecycleState::Draining => "LifecycleState::Draining",
        crate::ir::LifecycleState::Quiesced => "LifecycleState::Quiesced",
        crate::ir::LifecycleState::Offline => "LifecycleState::Offline",
    }
}

fn ingest_eviction_policy_to_rust(
    policy: &crate::ir::TelemetryIngestEvictionPolicy,
) -> &'static str {
    match policy {
        crate::ir::TelemetryIngestEvictionPolicy::Refuse => "TelemetryIngestEvictionPolicy::Refuse",
        crate::ir::TelemetryIngestEvictionPolicy::EvictOldest => {
            "TelemetryIngestEvictionPolicy::EvictOldest"
        }
    }
}

fn telemetry_schema_label(schema: &crate::ir::TelemetryFrameSchema) -> &'static str {
    match schema {
        crate::ir::TelemetryFrameSchema::LegacyPlaintext => "legacy-plaintext",
        crate::ir::TelemetryFrameSchema::CborV1 => "cbor-v1",
    }
}

fn cas_signing_key_literal(manifest: &Manifest, manifest_dir: Option<&Path>) -> Result<String> {
    let key_path = manifest
        .cas
        .signing
        .as_ref()
        .and_then(|signing| signing.key_path.as_deref())
        .map(str::trim)
        .filter(|value| !value.is_empty());
    let Some(path) = key_path else {
        return Ok("None".to_owned());
    };
    let resolved = resolve_manifest_relative_path(manifest_dir, path);
    let key_bytes = fs::read(&resolved)
        .with_context(|| format!("failed to read cas signing key {}", resolved.display()))?;
    let key_text = std::str::from_utf8(&key_bytes)
        .with_context(|| format!("cas signing key {} is not valid UTF-8", resolved.display()))?;
    let raw = hex::decode(key_text.trim()).map_err(|err| {
        anyhow::anyhow!("cas signing key {} must be hex: {err}", resolved.display())
    })?;
    if raw.len() != 32 {
        return Err(anyhow::anyhow!(
            "cas signing key {} must be 32 bytes (got {})",
            resolved.display(),
            raw.len()
        ));
    }
    let mut key = [0u8; 32];
    key.copy_from_slice(&raw);
    let literal = key
        .iter()
        .map(|byte| format!("0x{byte:02x}"))
        .collect::<Vec<_>>()
        .join(", ");
    Ok(format!("Some([{literal}])"))
}

#[derive(Serialize)]
struct PolicyRuleSnapshot<'a> {
    id: &'a str,
    target: &'a str,
}

#[derive(Serialize)]
struct PolicyLimitsSnapshot {
    queue_max_entries: u16,
    queue_max_bytes: u32,
    ctl_max_bytes: u32,
    status_max_bytes: u32,
}

#[derive(Serialize)]
struct PolicyRulesSnapshot<'a> {
    enabled: bool,
    limits: PolicyLimitsSnapshot,
    rules: Vec<PolicyRuleSnapshot<'a>>,
}

fn render_policy_rules_json(manifest: &Manifest) -> Result<String> {
    let policy = &manifest.ecosystem.policy;
    let snapshot = PolicyRulesSnapshot {
        enabled: policy.enable,
        limits: PolicyLimitsSnapshot {
            queue_max_entries: policy.queue_max_entries,
            queue_max_bytes: policy.queue_max_bytes,
            ctl_max_bytes: policy.ctl_max_bytes,
            status_max_bytes: policy.status_max_bytes,
        },
        rules: policy
            .rules
            .iter()
            .map(|rule| PolicyRuleSnapshot {
                id: rule.id.as_str(),
                target: rule.target.as_str(),
            })
            .collect(),
    };
    let json =
        serde_json::to_string_pretty(&snapshot).context("serialize policy rules snapshot")?;
    Ok(json)
}

fn build_event_pump_fds(manifest: &Manifest) -> Vec<&'static str> {
    let mut fds = Vec::new();
    if manifest.features.serial_console {
        fds.push("serial");
    }
    fds.push("timer");
    fds.push("ipc");
    if manifest.features.net_console {
        fds.push("net-console");
    }
    fds.push("ninedoor");
    fds
}

fn build_shard_labels(manifest: &Manifest) -> Vec<String> {
    let count = if manifest.sharding.enabled {
        1usize << manifest.sharding.shard_bits
    } else {
        1
    };
    (0..count).map(|idx| format!("{:02x}", idx)).collect()
}

fn build_audit_lines(
    manifest: &Manifest,
    manifest_hash: &str,
    event_pump_fds: &[&'static str],
) -> Vec<String> {
    vec![
        format!("manifest.schema={}", manifest.root_task.schema),
        format!("manifest.profile={}", manifest.profile.name),
        format!("manifest.sha256={}", manifest_hash),
        format!("manifest.tickets={}", manifest.tickets.len()),
        format!(
            "manifest.namespaces={} role_isolation={}",
            manifest.namespaces.mounts.len(),
            manifest.namespaces.role_isolation
        ),
        format!("manifest.secure9p.msize={}", manifest.secure9p.msize),
        format!(
            "manifest.secure9p.walk_depth={}",
            manifest.secure9p.walk_depth
        ),
        format!(
            "manifest.secure9p.tags_per_session={}",
            manifest.secure9p.tags_per_session
        ),
        format!(
            "manifest.secure9p.batch_frames={}",
            manifest.secure9p.batch_frames
        ),
        format!(
            "manifest.secure9p.short_write.policy={}",
            short_write_policy_label(&manifest.secure9p.short_write.policy)
        ),
        format!("manifest.sharding.enabled={}", manifest.sharding.enabled),
        format!(
            "manifest.sharding.shard_bits={}",
            manifest.sharding.shard_bits
        ),
        format!(
            "manifest.sharding.legacy_worker_alias={}",
            manifest.sharding.legacy_worker_alias
        ),
        format!(
            "manifest.sharding.shard_count={}",
            build_shard_labels(manifest).len()
        ),
        format!(
            "telemetry.ring_bytes_per_worker={}",
            manifest.telemetry.ring_bytes_per_worker
        ),
        format!(
            "telemetry.frame_schema={}",
            telemetry_schema_label(&manifest.telemetry.frame_schema)
        ),
        format!(
            "telemetry.cursor.retain_on_boot={}",
            manifest.telemetry.cursor.retain_on_boot
        ),
        format!("manifest.cache.kernel_ops={}", manifest.cache.kernel_ops),
        format!("manifest.cache.dma_clean={}", manifest.cache.dma_clean),
        format!(
            "manifest.cache.dma_invalidate={}",
            manifest.cache.dma_invalidate
        ),
        format!(
            "manifest.cache.unify_instructions={}",
            manifest.cache.unify_instructions
        ),
        format!(
            "manifest.features.net_console={}",
            manifest.features.net_console
        ),
        format!("event_pump.fds={}", event_pump_fds.join(",")),
    ]
}

fn write_if_changed(path: &Path, contents: &str) -> Result<()> {
    // Always rewrite so mtimes advance when the manifest changes; build.rs enforces freshness by time.
    fs::write(path, contents).with_context(|| format!("failed to write {}", path.display()))?;
    Ok(())
}

fn escape_literal(value: &str) -> String {
    value.chars().flat_map(|c| c.escape_default()).collect()
}
