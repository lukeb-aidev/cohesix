// Author: Lukas Bower
// Purpose: Define and export the CBOR telemetry frame schema for docs.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

use super::hash_bytes;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct TelemetryField {
    pub name: &'static str,
    pub cbor_type: &'static str,
    pub required: bool,
    pub description: &'static str,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct TelemetryCborSchema {
    pub schema: &'static str,
    pub version: u8,
    pub fields: Vec<TelemetryField>,
}

impl TelemetryCborSchema {
    pub fn v1() -> Self {
        Self {
            schema: "telemetry-frame/v1",
            version: 1,
            fields: vec![
                TelemetryField {
                    name: "schema",
                    cbor_type: "text",
                    required: true,
                    description: "Schema identifier; must be `telemetry-frame/v1`.",
                },
                TelemetryField {
                    name: "worker_id",
                    cbor_type: "text",
                    required: true,
                    description: "Worker identifier emitting the record.",
                },
                TelemetryField {
                    name: "role",
                    cbor_type: "text",
                    required: true,
                    description: "Worker role label (`worker-heartbeat`, `worker-gpu`).",
                },
                TelemetryField {
                    name: "seq",
                    cbor_type: "uint",
                    required: true,
                    description: "Monotonic frame sequence number.",
                },
                TelemetryField {
                    name: "emitted_ms",
                    cbor_type: "uint",
                    required: true,
                    description: "Unix epoch milliseconds captured by the worker.",
                },
                TelemetryField {
                    name: "payload",
                    cbor_type: "map",
                    required: true,
                    description: "Schema-specific payload map (e.g., heartbeat or GPU job data).",
                },
            ],
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct TelemetryFrameV1 {
    pub schema: String,
    pub worker_id: String,
    pub role: String,
    pub seq: u64,
    pub emitted_ms: u64,
    pub payload: serde_cbor::Value,
}

pub struct CborSnippet {
    pub markdown: String,
    pub hash: String,
}

pub fn telemetry_cbor_snippet() -> Result<CborSnippet> {
    let schema = TelemetryCborSchema::v1();
    let encoded = serde_json::to_vec(&schema).context("serialize CBOR schema")?;
    let hash = hash_bytes(&encoded);
    let mut markdown = String::new();
    writeln!(markdown, "### Telemetry CBOR Frame v1 (generated)")?;
    writeln!(markdown, "- Schema: `{}`", schema.schema)?;
    writeln!(markdown, "- Version: `{}`", schema.version)?;
    writeln!(markdown, "- Encoding: CBOR map (major type 5)")?;
    writeln!(markdown)?;
    writeln!(markdown, "| Field | CBOR type | Required | Description |")?;
    writeln!(markdown, "| --- | --- | --- | --- |")?;
    for field in &schema.fields {
        writeln!(
            markdown,
            "| `{}` | `{}` | `{}` | {} |",
            field.name,
            field.cbor_type,
            if field.required { "yes" } else { "no" },
            field.description
        )?;
    }
    writeln!(
        markdown,
        "\n_Generated by coh-rtc (sha256: `{}`)._",
        hash
    )?;
    Ok(CborSnippet { markdown, hash })
}

pub fn emit_cbor_snippet(path: &Path) -> Result<()> {
    let snippet = telemetry_cbor_snippet()?;
    let mut contents = String::new();
    writeln!(contents, "<!-- Author: Lukas Bower -->")?;
    writeln!(
        contents,
        "<!-- Purpose: Generated CBOR telemetry schema snippet for docs/INTERFACES.md. -->"
    )?;
    writeln!(contents)?;
    writeln!(contents, "{}", snippet.markdown.trim_end())?;
    fs::write(path, contents)
        .with_context(|| format!("failed to write CBOR schema snippet {}", path.display()))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cbor_frame_roundtrip() {
        let mut payload = std::collections::BTreeMap::new();
        payload.insert(
            serde_cbor::Value::Text("tick".to_owned()),
            serde_cbor::Value::Integer(42.into()),
        );
        let frame = TelemetryFrameV1 {
            schema: "telemetry-frame/v1".to_owned(),
            worker_id: "worker-1".to_owned(),
            role: "worker-heartbeat".to_owned(),
            seq: 4,
            emitted_ms: 42,
            payload: serde_cbor::Value::Map(payload),
        };
        let encoded = serde_cbor::to_vec(&frame).expect("encode cbor frame");
        let decoded: TelemetryFrameV1 = serde_cbor::from_slice(&encoded).expect("decode cbor");
        assert_eq!(decoded, frame);
    }

    #[test]
    fn snippet_hash_is_deterministic() {
        let first = telemetry_cbor_snippet().expect("snippet");
        let second = telemetry_cbor_snippet().expect("snippet again");
        assert_eq!(first.hash, second.hash);
        assert_eq!(first.markdown, second.markdown);
    }
}
