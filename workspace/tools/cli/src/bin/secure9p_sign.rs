// CLASSIFICATION: COMMUNITY
// Filename: secure9p_sign.rs v0.1
// Author: Lukas Bower
// Date Modified: 2029-09-26

use chrono::Utc;
use clap::Parser;
use cohesix::trace::recorder::event;
use cohesix::{coh_bail, CohError};
use cohesix_secure9p::manifest::ManifestSignature;
use std::fs;
use std::path::PathBuf;

#[derive(Parser, Debug)]
#[command(about = "Sign a Secure9P manifest using SHA-512", rename_all = "kebab")]
struct Args {
    /// Path to the Secure9P manifest (TOML).
    #[arg(long)]
    manifest: PathBuf,
    /// Optional output path for the signature file.
    #[arg(long)]
    output: Option<PathBuf>,
    /// When set, do not prepend metadata headers to the signature file.
    #[arg(long)]
    no_header: bool,
}

fn main() -> Result<(), CohError> {
    let args = Args::parse();
    let manifest_bytes = fs::read(&args.manifest)?;
    if manifest_bytes.is_empty() {
        coh_bail!("manifest {} is empty", args.manifest.display());
    }
    let signature = ManifestSignature::compute(&manifest_bytes);
    let out_path = args
        .output
        .clone()
        .unwrap_or_else(|| ManifestSignature::signature_path(&args.manifest));
    let header = if args.no_header {
        None
    } else {
        let today = Utc::now().format("%Y-%m-%d");
        Some(format!(
            "// CLASSIFICATION: COMMUNITY\n// Generated by secure9p-sign\n// Author: Lukas Bower\n// Date Generated: {}",
            today
        ))
    };
    signature.write(&out_path, header.as_deref())?;
    event(
        "secure9p_sign",
        "signature_written",
        &format!(
            "manifest={} output={} algorithm={}",
            args.manifest.display(),
            out_path.display(),
            signature.algorithm
        ),
    );
    println!(
        "Secure9P manifest signature written to {}",
        out_path.display()
    );
    Ok(())
}
