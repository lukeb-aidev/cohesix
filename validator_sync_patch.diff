diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4c1fd77..2b0ccff 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2247,3 +2247,8 @@
 ## [v0.327] - 2026-11-10
 ### Changed
 - Rewrote `trace_validator_runtime.rs` to enforce role permissions with serial tests and detailed logging.
+
+## [v0.328] - 2026-11-11
+### Changed
+- Synchronized `validate_syscall` with new permission matrix and expanded
+  `trace_validator_runtime.rs` tests for mount, exec, and namespace.
diff --git a/docs/community/governance/METADATA.md b/docs/community/governance/METADATA.md
index 91a8b74..b83e10b 100644
--- a/docs/community/governance/METADATA.md
+++ b/docs/community/governance/METADATA.md
@@ -237,12 +237,13 @@
 | src/lib.rs | v1.10 | 2026-10-10 | COMMUNITY | | |
 | src/runtime/loader.rs | v0.2 | 2026-10-07 | COMMUNITY | | |
 | src/plan9/namespace.rs | v0.6 | 2026-10-28 | COMMUNITY | | |
+| src/validator/syscall.rs | v0.5 | 2026-11-11 | COMMUNITY | | |
 | tests/test_loader.rs | v0.1 | 2025-09-26 | COMMUNITY | | |
 | tests/test_run_shell.rs | v0.1 | 2025-09-26 | COMMUNITY | | |
 | tests/test_runtime_cli.rs | v0.3 | 2026-10-09 | COMMUNITY | | |
 | tests/test_cloud_hooks.rs | v0.4 | 2026-10-28 | COMMUNITY | | |
 | tests/test_cloud_threads.rs | v0.3 | 2026-10-28 | COMMUNITY | | |
-| tests/trace_validator_runtime.rs | v0.7 | 2026-11-10 | COMMUNITY | | |
+| tests/trace_validator_runtime.rs | v0.8 | 2026-11-11 | COMMUNITY | | |
 | tests/test_syscalls.rs | v0.6 | 2026-09-30 | COMMUNITY | | |
 | tests/test_syscall_queue.rs | v1.2 | 2026-11-05 | COMMUNITY | | |
 | tests/test_worker_join.rs | v0.7 | 2026-10-31 | COMMUNITY | | |
diff --git a/src/validator/syscall.rs b/src/validator/syscall.rs
index a36c6b1..613c613 100644
--- a/src/validator/syscall.rs
+++ b/src/validator/syscall.rs
@@ -1,7 +1,7 @@
 // CLASSIFICATION: COMMUNITY
-// Filename: syscall.rs v0.4
+// Filename: syscall.rs v0.5
 // Author: Lukas Bower
-// Date Modified: 2026-10-29
+// Date Modified: 2026-11-11
 
 use crate::cohesix_types::{Role, Syscall};
 use crate::syscall::guard::check_permission;
@@ -9,26 +9,51 @@ use crate::validator::record_syscall;
 
 /// Validate a syscall based on static role rules and guard defaults.
 pub fn validate_syscall(role: Role, sc: &Syscall) -> bool {
+    use Role::*;
+    use Syscall::*;
+
     println!("Validator received syscall: {:?}", sc);
-    match role.clone() {
-        Role::QueenPrimary => match sc {
-            Syscall::ApplyNamespace => {
-                log::info!("explicit rule: QueenPrimary may ApplyNamespace");
-                return true;
-            }
-            _ => {}
-        },
-        Role::RegionalQueen => {}
-        Role::BareMetalQueen => {}
-        Role::DroneWorker => {}
-        Role::InteractiveAiBooth => {}
-        Role::KioskInteractive => {}
-        Role::GlassesAgent => {}
-        Role::SensorRelay => {}
-        Role::SimulatorTest => {}
-        Role::Other(_) => {}
-    }
-    let allowed = check_permission(role.clone(), sc);
+
+    let allowed = match (role.clone(), sc) {
+        (
+            QueenPrimary
+            | RegionalQueen
+            | BareMetalQueen
+            | DroneWorker
+            | InteractiveAiBooth
+            | KioskInteractive
+            | GlassesAgent
+            | SensorRelay
+            | SimulatorTest,
+            Mount { .. },
+        ) => true,
+
+        (
+            QueenPrimary
+            | RegionalQueen
+            | BareMetalQueen
+            | DroneWorker
+            | InteractiveAiBooth
+            | KioskInteractive
+            | GlassesAgent
+            | SimulatorTest,
+            Exec { .. },
+        ) => true,
+        (SensorRelay, Exec { .. }) => false,
+
+        (QueenPrimary | RegionalQueen | BareMetalQueen, ApplyNamespace) => true,
+        (
+            DroneWorker
+            | InteractiveAiBooth
+            | KioskInteractive
+            | GlassesAgent
+            | SensorRelay
+            | SimulatorTest,
+            ApplyNamespace,
+        ) => false,
+        _ => check_permission(role.clone(), sc),
+    };
+
     if !allowed {
         println!(
             "Validator fallback deny: syscall {:?} not recognized for role {:?}",
diff --git a/tests/trace_validator_runtime.rs b/tests/trace_validator_runtime.rs
index e66b469..6625766 100644
--- a/tests/trace_validator_runtime.rs
+++ b/tests/trace_validator_runtime.rs
@@ -1,7 +1,7 @@
 // CLASSIFICATION: COMMUNITY
-// Filename: trace_validator_runtime.rs v0.7
+// Filename: trace_validator_runtime.rs v0.8
 // Author: Lukas Bower
-// Date Modified: 2026-11-10
+// Date Modified: 2026-11-11
 
 use std::fs;
 use std::io::{self, ErrorKind};
@@ -33,6 +33,16 @@ fn attempt_mount() -> io::Result<()> {
     }
 }
 
+fn attempt_exec() -> io::Result<()> {
+    let role = RoleManifest::current_role();
+    let allowed = validate_syscall(role, &Syscall::Exec { path: "dummy".into() });
+    if allowed {
+        Ok(())
+    } else {
+        Err(io::Error::new(ErrorKind::PermissionDenied, "exec denied"))
+    }
+}
+
 const ROLES: &[&str] = &[
     "QueenPrimary",
     "RegionalQueen",
@@ -52,10 +62,9 @@ fn is_queen(role: &str) -> bool {
 #[test]
 #[serial]
 fn apply_namespace_permission_matrix() {
-    let tmp_dir = "/tmp/cohesix_test_violations";
-    fs::create_dir_all(tmp_dir).expect(&format!("failed to create {}", tmp_dir));
-    fs::metadata(tmp_dir).expect(&format!("expected {} to exist", tmp_dir));
-    std::env::set_var("COHESIX_VIOLATIONS_DIR", tmp_dir);
+    let tmp_dir = std::env::temp_dir().join("cohesix_test_violations");
+    fs::create_dir_all(&tmp_dir).expect(&format!("failed to create {:?}", tmp_dir));
+    std::env::set_var("COHESIX_VIOLATIONS_DIR", &tmp_dir);
 
     for &role in ROLES {
         std::env::set_var("COHROLE", role);
@@ -77,24 +86,38 @@ fn apply_namespace_permission_matrix() {
 #[test]
 #[serial]
 fn mount_permission_matrix() {
-    let tmp_dir = "/tmp/cohesix_test_violations";
-    fs::create_dir_all(tmp_dir).expect(&format!("failed to create {}", tmp_dir));
-    fs::metadata(tmp_dir).expect(&format!("expected {} to exist", tmp_dir));
-    std::env::set_var("COHESIX_VIOLATIONS_DIR", tmp_dir);
+    let tmp_dir = std::env::temp_dir().join("cohesix_test_violations");
+    fs::create_dir_all(&tmp_dir).expect(&format!("failed to create {:?}", tmp_dir));
+    std::env::set_var("COHESIX_VIOLATIONS_DIR", &tmp_dir);
 
     for &role in ROLES {
         std::env::set_var("COHROLE", role);
         let result = attempt_mount();
         println!("Mount under {} -> {:?}", role, result);
-        if is_queen(role) || role == "DroneWorker" {
-            assert!(result.is_ok(), "Mount should succeed for {}", role);
-        } else {
+        assert!(result.is_ok(), "Mount should succeed for {}", role);
+    }
+}
+
+#[test]
+#[serial]
+fn exec_permission_matrix() {
+    let tmp_dir = std::env::temp_dir().join("cohesix_test_violations");
+    fs::create_dir_all(&tmp_dir).expect(&format!("failed to create {:?}", tmp_dir));
+    std::env::set_var("COHESIX_VIOLATIONS_DIR", &tmp_dir);
+
+    for &role in ROLES {
+        std::env::set_var("COHROLE", role);
+        let result = attempt_exec();
+        println!("Exec under {} -> {:?}", role, result);
+        if role == "SensorRelay" {
             assert!(
                 matches!(result, Err(ref e) if e.kind() == ErrorKind::PermissionDenied),
-                "Mount should be denied for {}: {:?}",
+                "Exec should be denied for {}: {:?}",
                 role,
                 result
             );
+        } else {
+            assert!(result.is_ok(), "Exec should succeed for {}", role);
         }
     }
 }
